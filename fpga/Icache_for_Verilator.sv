// Generated by CIRCT firtool-1.38.0
// VCS coverage exclude_file
module mem_combMem(
  input  [12:0] R0_addr,
  input         R0_en,
                R0_clk,
  input  [12:0] W0_addr,
  input         W0_en,
                W0_clk,
  input  [31:0] W0_data,
  input  [3:0]  W0_mask,
  output [31:0] R0_data
);

  (* rw_addr_collision = "yes" *)
  reg [31:0] Memory[0:8191];

  initial begin
    $readmemh("vector_matmul_inst.mem", Memory);
  end

  reg        _GEN;
  reg [12:0] _GEN_0;
  always @(posedge R0_clk) begin
    _GEN <= R0_en;
    _GEN_0 <= R0_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en & W0_mask[0])
      Memory[W0_addr][32'h0 +: 8] <= W0_data[7:0];
    if (W0_en & W0_mask[1])
      Memory[W0_addr][32'h8 +: 8] <= W0_data[15:8];
    if (W0_en & W0_mask[2])
      Memory[W0_addr][32'h10 +: 8] <= W0_data[23:16];
    if (W0_en & W0_mask[3])
      Memory[W0_addr][32'h18 +: 8] <= W0_data[31:24];
  end // always @(posedge)
  assign R0_data = _GEN ? Memory[_GEN_0] : 32'bx;
endmodule

module Icache_for_Verilator(
  input         clock,
                reset,
                io_ar_valid,
  input  [63:0] io_ar_bits_addr,
  input  [2:0]  io_ar_bits_prot,
  input         io_aw_valid,
  input  [63:0] io_aw_bits_addr,
  input  [2:0]  io_aw_bits_prot,
  input         io_b_ready,
                io_r_ready,
                io_w_valid,
  input  [31:0] io_w_bits_data,
  input  [3:0]  io_w_bits_strb,
  output        io_ar_ready,
                io_aw_ready,
                io_b_valid,
  output [2:0]  io_b_bits_resp,
  output        io_r_valid,
  output [31:0] io_r_bits_data,
  output [2:0]  io_r_bits_resp,
  output        io_w_ready
);

  wire        _io_r_valid_output;
  wire [31:0] _mem_ext_R0_data;
  reg  [31:0] r_channel_bits_reg_data;
  reg  [2:0]  r_channel_bits_reg_resp;
  reg         r_channel_valid_reg;
  wire        r_stall = _io_r_valid_output & ~io_r_ready;
  reg         retain_r_channel;
  reg         r_channel_valid_reg_REG;
  reg         io_r_valid_REG;
  assign _io_r_valid_output = retain_r_channel ? r_channel_valid_reg : io_r_valid_REG;
  reg         b_valid;
  wire        mem_MPORT_en = io_aw_valid & io_w_valid;
  always @(posedge clock) begin
    if (r_stall & retain_r_channel) begin
    end
    else begin
      r_channel_bits_reg_data <= _mem_ext_R0_data;
      r_channel_bits_reg_resp <= 3'h0;
    end
    if (r_stall) begin
      if (retain_r_channel) begin
      end
      else
        r_channel_valid_reg <= io_r_valid_REG;
    end
    else
      r_channel_valid_reg <= r_channel_valid_reg_REG;
    retain_r_channel <= r_stall;
    r_channel_valid_reg_REG <= io_ar_valid & ~r_stall;
    io_r_valid_REG <= io_ar_valid & ~r_stall;
    if (reset)
      b_valid <= 1'h0;
    else
      b_valid <= mem_MPORT_en;
  end // always @(posedge)
  mem_combMem mem_ext (
    .R0_addr (io_ar_bits_addr[14:2]),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .W0_addr (io_aw_bits_addr[14:2]),
    .W0_en   (mem_MPORT_en),
    .W0_clk  (clock),
    .W0_data (io_w_bits_data),
    .W0_mask (io_w_bits_strb),
    .R0_data (_mem_ext_R0_data)
  );
  assign io_ar_ready = ~r_stall;
  assign io_aw_ready = 1'h1;
  assign io_b_valid = b_valid;
  assign io_b_bits_resp = 3'h0;
  assign io_r_valid = _io_r_valid_output;
  assign io_r_bits_data = retain_r_channel ? r_channel_bits_reg_data : _mem_ext_R0_data;
  assign io_r_bits_resp = retain_r_channel ? r_channel_bits_reg_resp : 3'h0;
  assign io_w_ready = 1'h1;
endmodule

